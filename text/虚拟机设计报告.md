# 虚拟机设计报告



[TOC]



## 一、基本信息

### 1. 实验目的

​	此虚拟机是计算机组成原理课程设计的一项重要内容，目的是通过高级语言实现软件，模拟冯诺依曼结构计算机系统及其工作原理，直观地显示机器运行的过程，综合运用软硬件知识，提升自身对计算机的认知水平。

###2. 虚拟机基本信息

​	本次实验使用高级语言构建虚拟机，模拟冯诺依曼结构计算机的运行。此虚拟机使用Java 8(Intellij IDEA) 开发，测试环境为Windows 10 64bit，拥有文本和图形用户界面。存储系统包含寄存器与主存以及文件设备，不设缓存。指令系统源自Y86-64架构，目前仅支持有符号64位整型的算数与逻辑运算。

## 二、组成部件

_结构示意图_：

![](F:\programming\workspace\DyVM\text\structure.png)

* **控制器**：通过函数来控制各部件的运行，模拟控制器的工作。

* **运算器**：用高级语言的计算功能模拟运算器的工作。

* **寄存器**：15个通用寄存器，3个专用寄存器。通用寄存器使用长度为15的64位整型向量来模拟；专用寄存器用成员变量保存。

* **IO桥接器**：提供虚拟地址映射。

* **存储器**：用字节数组模拟。

* **键盘输入部件**：用数组模拟输入缓冲区，与存储器共用虚拟地址编码。

* **文本输出部件**：用数组模拟输出缓冲区，与存储器共用虚拟地址编码。

* **显示设备**：用数组模拟显示缓冲区，与存储器共用虚拟地址编码

* **总线**：体现为控制函数中的参数和局部变量，起到传输数据的作用。

  ​

  _外观/设计图_:

  ![](设计图.png)

  

  _各部分说明_：

  * 左上角为**显示屏**，分辨率为200 X 125，默认黑色背景。支持RGBA颜色空间，对Alpha通道尚未提供完全的支持。
  * 右上角为**处理器信息**，实时显示15个寄存器保存的数值以及程序计数器中保存的值。其下方6个按钮分别是：
    * 加载（Load）：从文件加载可执行目标文件；
    * 慢速运行（Run）：以约1000Hz的速率运行程序；
    * 快速运行（Fast）：以约15MHz的速率运行程序；
    * 暂停（Pause）：暂停运行；
    * 单步运行（Step）：单步运行程序；
    * 停机（Halt）：终止程序运行，并将程序状态恢复为刚载入时的状态。
  * 左下角为**输入和输出窗口**，左侧为输入窗口，目前尚未实现；右侧为输出窗口，显示来自处理器的输出，不能手动修改。
  * 右下角为**内存监视器**，最多支持10个条目的检测，每个条目中左侧是地址输入框，可以读取10进制或16进制整数，输入内存地址后右侧文本框会实时显示以输入地址为起始16字节的数据。

  _效果图_:

   ![](F:\programming\workspace\DyVM\text\DyVM1.png)




## 三、处理器架构

**DY64**：源自Y86-64 ISA（CS:APP第四章所描述的指令集架构)，在其基础上做了一些修改和扩充。

### 1. 通用寄存器与寻址方式

####i. 寄存器列表：

| 编号 | 名称 | 功能         |
| ---- | ---- | ------------ |
| 0    | %rax | 函数返回值   |
| 1    | %rcx | 第四个参数   |
| 2    | %rdx | 第三个参数   |
| 3    | %rbx | 被调用者保存 |
| 4    | %rsp | 栈指针寄存器 |
| 5    | %rbp | 被调用者保存 |
| 6    | %rsi | 第二个参数   |
| 7    | %rdi | 第一个参数   |
| 8    | %r8  | 第五个参数   |
| 9    | %r9  | 第六个参数   |
| A    | %r10 | 调用者保存   |
| B    | %r11 | 调用者保存   |
| C    | %r12 | 被调用者保存 |
| D    | %r13 | 被调用者保存 |
| E    | %r14 | 被调用者保存 |

####ii. 寻址方式：

`R` 代表寄存器文件，`M` 代表存储器。

| 类型   | 格式       | 操作数值        | 名称            |
| ------ | ---------- | --------------- | --------------- |
| 立即数 | `$Imm`     | `Imm`           | 立即数寻址      |
| 寄存器 | `r_a`      | `R[r_a]`        | 寄存器寻址      |
| 存储器 | `Imm()`    | `M[Imm]`        | 绝对寻址        |
| 存储器 | `(r_b)`    | `M[R[r_b]]`     | 间接寻址        |
| 存储器 | `Imm(r_b)` | `M[Imm+R[r_b]]` | 基址+偏移量寻址 |



### 2. 特殊功能寄存器

* 程序计数器（PC）：记录下一条取指地址
* 指令寄存器（IR）：记录当前指令
* 条件码寄存器（CC）：记录当前条件码（溢出，负数，零，中断等）
* 机器状态（State）：记录当前机器状态（正常，各种类型异常）



### 3. 机器状态
​	**机器状态（State）**有如下类型：

| no   | 标识符 | 含义           |
| ---- | ------ | -------------- |
| 0    | VM_OK  | 正常状态       |
| 1    | VM_HLT | 遇到停机指令   |
| 2    | VM_INS | 非法指令       |
| 3    | VM_REG | 非法寄存器表示 |
| 4    | VM_ADR | 非法内存引用   |
| 5    | VM_LOG | 逻辑错误       |
| 6    | VM_PC  | 指令地址错误   |

​	在目前的设计中，当程序运行出现异常后，处理器会直接终止运行，并将异常信息报告给外界。



### 4. 指令类型及格式

​	所有指令的第一个字节均为操作码，其中高4位（icode）代表指令种类，低4位（ifun）代表指令功能。所有包含寄存器ID的字节中，高4位代表第一个寄存器，低4位代表第二个寄存器（`0xF`代表不选中寄存器）。立即数均为64位，采用小端法存储。

​	目前共有7种类型的指令：

1. **null型**：无操作数，长度为一个字节。
2. **r型**：单操作数，操作数源为寄存器，长度为2字节。第2个字节存放寄存器id。
3. **rr型**：双操作数，操作数源均为寄存器，长度为2字节。第2个字节存放寄存器id。
4. **ir型**：双操作数，第一个操作数源为立即数，第二个操作数源为寄存器，长度为10字节。第2个字节存放寄存器id，第3-10字节存放立即数。
5. **rm型**：双操作数，第一个操作数源为寄存器，第二个操作数源为存储器的某个位置，长度为10字节。第2个字节存放寄存器id，第3-10字节存放立即数。
6. **mr型**：双操作数，第一个操作数源为存储器的某个位置，第二个操作数源为立即数，长度为10字节。第2个字节存放寄存器id，第3-10字节存放立即数。
7. **l型**：单操作数，在汇编指令该操作数中是代表指令地址的标签，在机器指令中是指令地址，长度为9字节。第2-9字节存放立即数。编写汇编代码时操作数为标签，在汇编时标签会被翻译成立即数。
8. **i型**：单操作数，操作数为立即数。第2-9字节存放立即数。

![](指令格式.png)

### 5. 取指流程

​	每次取指时，处理器会先加载mem[PC]位置的第一个字节，根据此字节的内容判断指令类型和长度，再依据判断结果读取相应字节数的指令，将取出的指令存放在ir（指令寄存器）中。处理器执行指令时会根据ir中的数据进行操作。

### 6. 指令列表

​	下列符号在指令中分别代表：

* `rA`,`rB`：寄存器ID
* `R`：寄存器，`R[rA]`表示寄存器rA中的值
* `m`：虚拟存储地址，寻址方式如上所述
* `M`：虚拟存储系统，可看作字节数组，`M[m]`表示地址m处的值
* `I`：立即数
* `Label`：标签，汇编器会将其翻译为立即数

####i. 特殊指令

| op码 | 指令名称与格式 | 功能     |
| ---- | -------------- | ------------- |
| 00   | halt           | 停机     |
| 01   | nop            | 空操作   |
| 02   | ret            | 函数返回`%rsp += 8, R[%rsp] -> pc` |
| 03 | iret | 中断返回 |

#### ii.传送指令

| op码 | 指令名称与格式 | 功能 |
| ---- | -------------- | ------------- |
| 10   | irmov i, rA         | 将立即数传送到寄存器`I -> R[rA]` |
| 20   | rmmovq rA, m          | 将寄存器中64位数据传送到主存`R[rA] -> M[m]` |
| 21 | rmmovl rA, m | 将寄存器中低32位数据传送到主存`R[rA] & 0xffffffff -> M[m]` |
| 22 | rmmovw rA, m | 将寄存器中低16位数据传送到主存`R[rA] & 0xffff -> M[m]` |
| 23 | rmmovb rA, m | 将寄存器中低8位数据传送到主存`R[rA] & 0xff -> M[m]` |
| 24  | mrmovq rA, m     | 将64位数据从主存传送到寄存器`M[m] -> R[rA]` |
| 25 | mrmovl rA, m | 将32位数据从主存传送到寄存器`M[m]& 0xffffffff -> R[rA]` |
| 26 | mrmovw rA, m | 将16位数据从主存传送到寄存器`M[m]& 0xffff -> R[rA]` |
| 27 | mrmovb rA, m | 将8位数据从主存传送到寄存器`M[m]& 0xff -> R[rA]` |
| 30 | rrmov rA, rB | 将数据从寄存器rA传送到寄存器rB `R[rA] -> R[rB]` |
| 31 | cmove | 条件传送，当状态码为相等（e）时发生传送`if equal then R[rA] -> R[rB]` |
| 32 | cmovne | 状态码为不相等（ne）时发生传送 `if not equal then R[rA] -> R[rB]` |
| 33 | cmovg | 状态吗为大于（g）时发生传送`if greater then R[rA] -> R[rB]` |
| 34 | cmovge | 状态码为大于等于（g）时发生传送`if greater or equal then R[rA] -> R[rB]` |
| 35 | cmovl | 状态码为小于（l）时发生传送`if less then R[rA] -> R[rB]` |
| 36 | cmovle | 状态吗为小于等于（g）时发生传送`if less or equal equal then R[rA] -> R[rB]` |

####iii. 双操作数算术与逻辑运算指令

更新条件码

| op码 | 指令名称与格式 | 功能 |
| ---- | -------------- | ------------- |
| 40 | add rA, rB |`R[rA] + R[rB] -> R[rA]`|
| 41 | sub rA, rB |`R[rA] - R[rB] -> R[rA]`|
| 42 | and rA, rB |`R[rA] & R[rB] -> R[rA]`|
| 43 | or rA, rB |`R[rA] | R[rB] -> R[rA]`|
| 44 | xor rA, rB |`R[rA] ^ R[rB] -> R[rA]`|
| 45 | sal rA, rB |`R[rA] << (R[rB] & 0x3f) -> R[rA] R[rA]`左移量为R[rB]的低6位|
| 46 | sar rA, rB |`R[rA] >> (R[rB] & 0x3f) -> R[rA]` 算术右移，填充符号位|
| 47 | shr rA, rB |`R[rA] >> (R[rB] & 0x3f) -> R[rA]` 逻辑右移，填充0|
| 48 | mul rA, rB |`R[rA] * R[rB] -> R[rA]`|
| 49 | idiv rA, rB |`R[rA] / R[rB] -> R[rA], R[rA] % R[rB] -> R[%rax]` 有符号数整除，商存放在R[rA]中，余数存放在R[%rax]中（注：如果`rA == %rax`，余数会被抛弃，不保存）|

####iv. 单操作数算术与逻辑运算指令 	

更新条件码

| op码 | 指令名称与格式 | 功能                                                      |
| ---- | -------------- | --------------------------------------------------------- |
| 50   | not rA         | `~(R[rA]) -> R[rA]`                                       |
| 51   | neg rA         | `-(R[rA]) -> R[rA]`                                       |
| 52   | inc rA         | `R[rA]++`                                                 |
| 53   | dec rA         | `R[rA]--`                                                 |
| 54   | cltq rA        | 对R[rA]的低32位进行符号拓展`(int64)(int32)R[rA] -> R[rA]` |
| 55   | cwtq rA        | 对R[rA]的低16位进行符号拓展`(int64)(int16)R[rA] -> R[rA]` |
| 56   | cbtq rA        | 对R[rA]的低8位进行符号拓展`(int64)(int8)R[rA] -> R[rA]`   |
| 57   | cqtl rA        | 保留R[rA]的低32位，其余位清零`R[rA] &= 0xffffffff`        |
| 58   | cqtw rA        | 保留R[rA]的低16位，其余位清零`R[rA] &= 0xffff`            |
| 59   | cqtb rA        | 保留R[rA]的低8位，其余位清零`R[rA] &= 0xff`               |

####v. 测试指令

更新条件码

| op码 | 指令名称与格式 | 功能                                                       |
| ---- | -------------- | ---------------------------------------------------------- |
| 60   | cmp rA, rB     | 将R[rA]与R[rB]比较大小`update cc with R[rA] - R[rB]`       |
| 61   | test rA, rB    | 将(R[rA] & R[rB])和0比较大小`update cc with R[rA] & R[rB]` |

####vi. 跳转指令

| op码 | 指令名称与格式            | 功能                                                         |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 70   | jmp label                 | 无条件跳转到label处`label -> pc`                             |
| 71   | je label                  | 比较结果为相等时跳转到label处`if equal then label -> pc`     |
| 72   | jne label                 | 结果为不相等时跳转到label处`if not equal then label -> pc`   |
| 73   | jg label                  | 结果为大于时跳转到label处`if greater then label -> pc`       |
| 74   | jge label                 | 结果为大于等于时跳转到label处`if greater or equal then label -> pc` |
| 75   | jl label                  | 结果为小于时跳转到label处`if less then label -> pc`          |
| 76   | jle label                 | 结果为小于等于时跳转到label处`if less or equal then label -> pc` |
| 77   | call label(function name) | 函数调用`%rsp -= 8, pc -> R[%rsp], label -> pc`              |

####vii. 堆栈操作

| op码 | 指令名称与格式 | 功能                                                  |
| ---- | -------------- | ----------------------------------------------------- |
| 80   | push rA        | 将R[rA]压进栈中`%rsp -= 8，R[rA] -> R[%rsp]`          |
| 81   | pop rA         | 弹出栈顶并保存至R[rA] `%rsp += 8, R[%rsp-8] -> R[rA]` |

####viii. 中断操作

| op码 | 指令名称与格式 | 功能                                  |
| ---- | -------------- | ------------------------------------- |
| 90   | int i          | 触发软中断（i为立即数，中断向量下标） |



### 7. 中断

#### i. 中断向量

​	目前的中断向量中只有两个有效地址：

* 地址2：清空输出缓冲区
* 地址3：将显存的内容显示到屏幕上

####ii. 中断操作的实现

​	当前版本的虚拟机没有真实地模拟中断操作，软件触发的陷阱（软中断）和普通指令的运行方式相同，没有设置中断标志位。此外，中断程序使用Java编写，而不是汇编语言，因为当前的指令集无法完备地支持虚拟机的所有操作。



## 四、虚拟存储系统


| 地址                    | 分区               |
| ----------------------- | ------------------ |
| 0x00000000 ~ 0x00ffffff | 预留空间           |
| 0x01000000 ~ 0x01ffffff | 用户代码区         |
| 0x02000000 ~ 0x02ffffff | 栈区（读写）       |
| 0x03000000 ~ 0x0fffffff | 用户数据区（读写） |
| 0x10000000 ~ 0x1007ffff | 输入缓冲区（只读） |
| 0x10080000 ~ 0x100fffff | 输出缓冲区（只写） |
| 0x10100000 ~ 0x10200000 | 显示缓冲区（只写） |

![](存储结构.png)

### 1. 预留空间

​	此部分空间为虚拟机预留的存储空间，存放了与IO和系统功能相关的信息，范围是[0x00000000, 0x01000000)。

​	地址0x0 ~ 0x7存放的64位整型数据存储的是输入缓冲区的大小，用于读入操作的实现（尚未实现）。

​	地址0x8 ~ 0xf存放的64位整型数据存储的是输出缓冲区的大小，用于输出操作的实现。

​	地址0x10 ~ 0x13存放的32位整型数据存储的是随机数种子，在程序加载到内存中时会被自动置入，用于伪随机随机函数的实现。

### 2. 用户代码区

​	该段区域存放二进制用户代码，范围是[0x01000000, 0x02000000)。

​	读入的目标文件代码会被放置在以地址0x01000000为起始的连续内存空间中，代码若超出用户代码区的长度则超出部分会被截断。加载完目标文件后，PC会被设置为目标文件中main函数的地址。该区段理论上是只读的，但是目前的实现中还没有对此区域进行保护，若操作不当，可能会使代码被修改。

### 3. 栈区

​	该段区域用于存放函数参数、返回地址以及函数的局部变量等数据，范围是[0x02000000, 0x03000000)。

​	运行时，栈顶向低地址方向扩张，即：栈底为高地址，栈顶为低地址。成功加载目标代码后，栈指针会被初始化为0x03000000（栈区的上边界）。入栈操作会将栈指针的值减去8并存入数据，出栈操作会将栈指针的值加上8并取出数据。在调用函数或函数返回指令过程中，PC值出入栈的操作会自动执行。另外，栈中数据的读写不只局限于栈顶，从栈顶到栈底的任意位置都可随机访问读写。

​	理论上，应有栈溢出检测机制，但从该虚拟机实现的复杂性上考虑，没有加入该功能。若操作不当致使栈溢出，可能会覆盖用户代码区的内容，导致运行错误。

###4. 用户数据区

​	此区域存放用户数据，范围是[0x03000000, 0x10000000)。

​	此区域用户可自由支配，用于存放全局变量，局部变量，数组等等。

### 5. 输入缓冲区

​	此区域存放来自键盘输入的临时数据，范围是[0x10000000, 0x10080000)。

​	缓冲区大小的数据（0x0 ~ 0x7）会实时反映缓冲区所含有效数据的字节数。目前输入尚未实现。

### 6. 输出缓冲区

​	此区域存放待输出的临时数据，范围是[0x10080000, 0x10100000)。

​	缓冲区大小的数据（0x8 ~ 0xf）**不会**实时反映缓冲区的有效字节数，但是在触发中断，**调用输出功能之时必须与缓冲区真实大小保持一致**，不然可能会导致输出结果异常。

###7. 显示缓冲区

​	此区域存放显示数据，范围是[0x10100000, 0x10200000)。

​	该区存放的即是每个像素的颜色信息，每个像素信息占四字节，其中R(Red)、G(Green)、B(Blue)、A(Alpha)各占一字节。当前的设计中，对Alpha通道还无法提供完整支持。由于显示器的分辨率为200 X 125，实际有效的数据区域范围是[0x10100000, 0x101186a0)。访问此存储区时，必须保证数据对齐，即，地址为4的倍数，且访存指令只能为`writel`。



##五、汇编语言

​	此虚拟机使用的汇编指令完全基于本机的指令系统。

###1. 语法单元

​	本机汇编语言共有5种语法单元：指令标识符、立即数、寄存器标识符、虚拟存储地址、地址标签。

​	**指令标识符**，唯一确定地标识指令，指令列表中所有指令的名称都是指令标识符。

​	**立即数**，用于立即数寻址，以字符    `$`开头，支持十进制或十六进制表示（十六进制需加上`0x`前缀，字母大小写均可）。

​	**寄存器标识符**，唯一确定地标识寄存器文件，用于寄存器寻址。寄存器列表中的所有寄存器名称都是寄存器标识符。

​	**虚拟存储地址**，唯一确定地标识虚拟存储地址，用于基址寻址、偏移量寻址和基址+偏移量寻址。格式为   `I(rB)`，其中`I`为立即数，不需要以`$`开头，支持十进制或十六进制表示（十六进制需加上`0x`前缀，字母大小写均可）；同时，`I`也可以是地址标签，汇编器会将地址标签替换为立即数；`rB`为寄存器标识符，表示基址寄存器。所表示的地址为`I+R[rB]`，`R[rB]`代表寄存器`rB`存储的数值。立即数和寄存器标识符均不省略时，寻址方式为基址+偏移量寻址；省略立即数时，寻址方式变为基址寻址；省略寄存器标识符时，寻址方式变为绝对寻址；两者不允许同时省略。

​	**地址标签**，表示下一条指令的起始地址，方便跳转指令和虚拟存储地址的编写。地址标签分为两类，一类是目的标签，另一类是源标签。目的标签表示的是跳转语句将要跳转的目的地址，标签末尾要写上`:`；源标签会在汇编过程中被替换为目的地址。函数名也是地址标签。汇编器提供了几个地址标签：

```
// 数据区段起始位置
data_sec_pos 0x03000000

// 存放输入缓冲区大小的位置
in_buf_size 0x00000000

// 输入缓冲区起始位置
in_buf_pos 0x10000000

// 存放输出缓冲区大小的位置
out_buf_size 0x00000008

// 输出缓冲区起始位置
out_buf_pos 0x10080000

// 显示缓冲区起始位置
disp_buf_pos 0x10100000

// 随机数种子的位置
random_seed_pos 0x00000010
```



###2. 语法要求

​	汇编器的语法要求有：

* 每条指令占一行，地址标签占一行；
* 字符`;`为单行注释符，从`;`字符起始到行末都为注释内容；
* * 无操作数指令格式为`instruction`;
  * 单操作数指令格式为`instruction <operand>`，指令标识符与操作数之间必须间隔一个空格;
  * 双操作数指令格式为`instruction <operand 1>, <operand 2>`，指令标识符于第一个操作数之间必须间隔一个空格，操作数1个操作数2之间必须间隔一个`,`和一个空格；
  * 目的标签末尾应加上`:`，如`main:`，`.L3:`等；源标签末尾不加`:`；源标签必须有唯一的目的标签相对应，目的标签则可以对应任意多个源标签；
* 每个汇编程序中必须有一个main函数，虚拟机将`main:`当作入口执行指令。



### 3. 函数调用

####i. 寄存器内容的保存

​	函数调用过程中，调用者寄存器的值应当被保存。从设计上说，一部分寄存器应由调用者保存，这些寄存器是 `%rax, %rcx, %rdx, %rsi, %rdi, %r8, %r9, %r10, %r11`，另一部分则由被调用者保存，这些寄存器是`%rbx, %rbp, %r12, %r13, %r14`。`%rsp`即栈指针寄存器，应由调用者和被调用者共同维护。

####ii. 函数参数

​	函数的前六个参数顺序是  `%rdi,%rsi,%rdx,%rcx,%r8,%r9`，第七、第八乃至更多的参数则由栈来传递。所有参数应当在调用函数之前就存入相应的寄存器或栈中。超出6个参数的部分，应当以逆序入栈，即，最后一个入栈的应是第七个参数。在调用函数时，返回地址会被压入栈中，因此对于被调用者而言第七个参数地址是`8(%rsp)`，第八个参数地址是`16(%rsp)`。

#### iii. 返回值

​	函数返回值保存在   `%rax` 中，若有多余一个返回值，可以利用指针传递返回值。



### 4. 库函数

​	汇编器提供了一些库函数，实现了打印数据、绘图、随机数等功能。以下列举了几个函数：

```
println	// 接收一个64位整型参数，将其当作有符号数打印并换行
draw	// 接受参数x，y, v，在显示器(x, y)位置绘制颜色为v的像素点
repaint	// 刷新显示屏，打印显示缓冲区的内容
random  // 随机数函数返回[0, 48271)之间的一个随机数
```






## 六、虚拟机实现框架

### 1. 程序结构

本程序使用java实现，主要包含以下代码文件：

* Main.java：完成虚拟机逻辑层面的组装与运行；
* Processor.java：实现处理器功能；
* AbstractFile.java：接口，为文件设备提供抽象接口；
* ReadableFile.java：接口，为可读设备提供抽象接口；
* WritableFile.java：接口，为可写设备提供抽象接口；
* IOBridge.java：IO桥接器，实现ReadableFIle和WritableFile接口，连接一切文件设备；
* Memory.java：主存，实现ReadableFIle和WritableFile接口；
* Keyboard.java：模拟键盘设备，实现ReadableFIle接口；
* TextOutput.java：文本输出设备，实现WritableFile接口；
* Display.java：模拟显示设备，实现WritableFile接口。

**注**：下列代码只是源代码的抽象示意，许多具体的实现细节没有在其中体现。



###2. 虚拟存储系统程序框架


#### i. AbstractFile接口

​	定义了getMaxSize(), isReadable(), isWritable()抽象方法。

```
interface AbstractFile {
methods:
	getMaxSize()
	isReadable()
	isWritable()
}
```



#### ii. ReadableFile接口

​	继承AbstractFile接口，定义了readq(), readl(), readw(), readb()四个读方法。

```
interface ReadableFile extends AbstractFile {
methods:
	readq()
	readl()
	readw()
	readb()
}
```



#### iii. WritableFile接口

​	继承AbstractFile接口，定义了writeq(), writel(), writew(), writeb()四个写方法。

```
interface WritableFile extends AbstractFile {
methods:
    writeq()
    writel()
    writew()
    writeb()
}
```



#### iv. Memory类

​	模拟主存，实现ReadableFile和WritableFile接口，用一维字节数组模拟主存存储空间。

```
class Memory implements ReadableFile, WritableFile {
variables:
	byte ram[MAX_SIZE] 	//随机访问存储器

methods:
    @Override {			// 继承自接口的方法
    	getMaxSize()
		isReadable()
		isWritable()
	    readq()
		readl()
		readw()
		readb()
		writeq()
    	writel()
    	writew()
    	writeb()
	}
	
	class MemoryPane extends Pane {
        monitors[10] 	//10个内存监视器条目
	}
}
```



#### v. Keyboard类

​	模拟键盘输入设备，实现ReadableFIle接口，用一维字节数组模拟输入缓冲区。

```
class Keyboard implements ReadableFile {
variables:
	byte ram[MAX_SIZE] 	//随机访问存储器

methods:
    @Override {			// 继承自接口的方法
    	getMaxSize()
		isReadable()
		isWritable()
	    readq()
		readl()
		readw()
		readb()
	}
	
	class KeyboardPane extends Pane {
	}
}
```



####vi. TextOutput类

​	模拟文本输出设备，实现WritableFile接口，用一维字节数组模拟输出缓冲区。

```
class TextOutput implements WritableFile {
variables:
	byte ram[MAX_SIZE] 	//随机访问存储器

methods:
    @Override {			// 继承自接口的方法
    	getMaxSize()
		isReadable()
		isWritable()
		writeq()
    	writel()
    	writew()
    	writeb()
	}
	
	class TextOutputPane extends Pane {
        TextArea textArea  	//输出文本框
        
    methods:
    	print()				//输出缓冲区内容
	}
}
```



#### vii. Display类

​	模拟显示输出设备，实现WritableFile接口，用一维字节数组模拟显示缓冲区。

```
class Display implements WritableFile {
variables:
	byte ram[MAX_SIZE] 	//随机访问存储器

methods:
    @Override {			// 继承自接口的方法
    	getMaxSize()
		isReadable()
		isWritable()
		writeq()
    	writel()
    	writew()
    	writeb()
	}
	
	class DisplayCanvas extends Canvas {
    methods:
    	paint() 		//绘图
	}
}
```



#### viii. IOBridge类

​	模拟IO桥接器，用来链接CPU与文件设备，实现了ReadableFile和WritableFIle接口。以下是IOBridge的简易框架：

```
class IOBridge implements ReadableFile, WritableFile {
variables:
	Memory memory
	Keyboard keyboard
	TextOutput textOutput
	Display display
	
	Processor processor
	
methods:
	loadObject()		// 加载目标文件的方法

	@Override {			// 继承自接口的方法
    	getMaxSize()
		isReadable()
		isWritable()
	    readq()
		readl()
		readw()
		readb()
		writeq()
    	writel()
    	writew()
    	writeb()
	}
}
```



### 3. 处理器程序框架

​	处理器包含15个通用寄存器，和专用寄存器：PC、IR、CC、State（如上所述）。考虑到设计复杂度和拟真程度等因素，该处理器使用非流水线化的结构以使运行流程变得更加简单、清晰。

​	其运行流程是：每一指令周期开始时，先从PC所给地指出取指，保存到IR中，然后运行指令，期间可能会更改CC中的值，或者读写内存和通用寄存器，最后更新PC的值。如运行过程中出现异常，处理器会更新State寄存器的内容并抛出异常。如果运行正常则进入下一指令周期。


​	以下是Processor的简易框架：

```
class Processor {
variables:
    IOBridge ioBridge
    
    long regs[15] //寄存器用一维64位整型数组模拟
    int pc //程序计数器
    byte cc //条件寄存器
    byte state //机器状态
    
    byte ir[10] //指令寄存器用字节数组模拟
    
methods:
    void fetch() //取指 + 计算下一PC地址
    // PC保存的值为目标文件中指令的绝对地址，在取指过程中会将PC映射到真实地址
    void exec() //译码 + 执行 + 访存 + 更新PC
    
    class ProcessorPane extends Pane {
        Button load		// 加载程序
        Button run		// 运行程序
        Button fast		// 快速运行程序
        Button pause	// 暂停
        Button step		// 单步运行
        Button halt		// 停机并复原初始状态
        
        registers & pc messages //寄存器和PC的值
    }
}
```



### 4. 主类框架

```
class Main extends Application {
variables:
	Processor processor
	IOBridge ioBridge
	Memory memory
	Keyboard keyboard
	TextOutput textOutput
	Display display
	
methods:
		void start()
}

Main.start() {
	//链接文件设备到处理器
    link memory, keyboard, textOutput, display to ioBridge
    link ioBridge to processor 
    
    init a scene
    add memoryPane, KeyboardPane, TextOutputPane,
    DisplayCanvas and ProcessPane to the scene
    
    add the scene to the stage
    show the stage
}
```



## 七、测试

​	为了检验虚拟机的正确性和性能，我编写了一些汇编程序进行测试

### 1. 求素数程序

​	该程序打印100以内的素数

```assembly
; program prime
; print all prime numbers below 100

; function prime(n) returns boolean
prime:
	irmov $2, %rdx ; i = 2
	irmov $1, %rax
	cmp %rdi, %rax ; n <= 1
	jg .L3
	xor %rax, %rax ; return 0
	ret
.L3:
	cmp %rdx, %rdi
	jge .L4
	rrmov %rdx, %rsi
	mul %rsi, %rdx
	cmp %rsi, %rdi  ; i * i > n ?
	jg .L4
	rrmov %rdi, %r8
	idiv %r8, %rdx	; n / i
	test %rax, %rax ; test n % i
	je .L4
	irmov $1, %rax
	inc %rdx			 ; i++
	jmp .L3
.L4:
	ret

; function main
main:
	irmov $2, %rcx ; i = 0
	irmov $100, %r10 ; limit = 0
.L1:
	rrmov %rcx, %rdi 
	call prime			; prime(i)
	test %rax, %rax
	je .L2
	rrmov %rcx, %rdi
	push %rcx
	push %r10
	call println
	pop %r10
	pop %rcx
.L2:
	inc %rcx
	cmp %rcx, %r10
	jl .L1
	halt
```

​	运行结果：
![](F:\programming\workspace\DyVM\text\DyVM2.png)



### 2. 生命游戏

​	该程序模拟康威生命游戏的运行。生命游戏是一种二维元胞自动机，具体规则可参考[维基百科-康威生命游戏](https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F)。其中细胞的颜色会随周期型变化。

```assembly
; function dx(x, d)
dx:
	push %rbx
	add %rdi, %rsi
	rrmov %rdi, %rax
	rrmov %rdi, %rbx
	irmov $200, %rsi
	add %rdi, %rsi
	sub %rbx, %rsi
	cmp %rax, %rsi
	cmovge %rbx, %rax
	test %rax, %rax
	cmovl %rdi, %rax
	pop %rbx
	ret

; function dy(y, d)
dy:
	push %rbx
	add %rdi, %rsi
	rrmov %rdi, %rax
	rrmov %rdi, %rbx
	irmov $125, %rsi
	add %rdi, %rsi
	sub %rbx, %rsi
	cmp %rax, %rsi
	cmovge %rbx, %rax
	test %rax, %rax
	cmovl %rdi, %rax
	pop %rbx
	ret

; function init
init:
; initialize the cell matrix
	push %rbx
	irmov $25000, %rbx
	irmov $7, %r8
	irmov $3, %r9
	irmov $1, %r10
	rrmov %rbx, %rdx
	xor %rcx, %rcx
.L2:
	call random
	and %rax, %r8
	xor %rdi, %rdi
	cmp %rax, %r9
	cmovl %r10, %rdi
	rmmovb %rdi, data_sec_pos(%rdx)
	inc %rcx
	inc %rdx
	cmp %rcx, %rbx
	jl .L2
	pop %rbx
	ret

; function next
next:
	push %rbx
	push %rbp
	push %r12
	push %r13
	push %r14
	irmov $25000, %rbx
	irmov $50000, %rbp

	xor %rcx, %rcx
;.L41:
;	rrmov %rcx, %rdx
;	add %rdx, %rbx
;	mrmovb data_sec_pos(%rdx), %rax
;	add %rdx, %rbx
;	rmmovb %rax, data_sec_pos(%rdx)
;	inc %rcx
;	cmp %rcx, %rbx
;	jl .L41

; calculate
	irmov $200, %r8
	irmov $125, %r9
	irmov $1, %r12
	irmov $-1, %r11
	xor %rcx, %rcx
	xor %r10, %r10
	rrmov %rbp, %rdx
.L3:
	; store x + 1
	rrmov %rcx, %rdi
	rrmov %r12, %rsi
	call dx
	push %rax ; push x + 1
	; store x - 1
	rrmov %rcx, %rdi
	rrmov %r11, %rsi
	call dx
	push %rax ; push x - 1
	push %rcx ; push x
	; store y + 1
	rrmov %r10, %rdi
	rrmov %r12, %rsi
	call dy
	push %rax ; push y + 1
	; store y - 1
	rrmov %r10, %rdi
	rrmov %r11, %rsi
	call dy
	push %rax ; push y - 1
	push %r10 ; push y
	; count
	xor %r14, %r14 ; count = 0
		; x-1, y-1
	mrmovq 32(%rsp), %rdi
	mrmovq 8(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x-1, y
	mrmovq 32(%rsp), %rdi
	mrmovq (%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x-1, y+1
	mrmovq 32(%rsp), %rdi
	mrmovq 16(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x, y-1
	mrmovq 24(%rsp), %rdi
	mrmovq 8(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x, y+1
	mrmovq 24(%rsp), %rdi
	mrmovq 16(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x+1, y-1
	mrmovq 40(%rsp), %rdi
	mrmovq 8(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x+1, y
	mrmovq 40(%rsp), %rdi
	mrmovq (%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
		; x+1, y+1
	mrmovq 40(%rsp), %rdi
	mrmovq 16(%rsp), %rsi
	mul %rdi, %r9
	add %rdi, %rsi
	add %rdi, %rbx
	mrmovb data_sec_pos(%rdi), %r13
	add %r14, %r13 ; count++ if alive
	; restore rsp
	irmov $48, %rax
	add %rsp, %rax
	push %r8
	push %r9
	irmov $2, %r8
	irmov $3, %r9
	cmp %r14, %r9
	jg .L6
	cmp %r14, %r8
	jl .L6
	jg .L7
	sub %rdx, %rbx
	mrmovb data_sec_pos(%rdx), %rax
	add %rdx, %rbx
	test %rax, %rax
	jne .L7
.L6:
	xor %rax, %rax
	jmp .L8
.L7:
	irmov $1, %rax
.L8:
	rmmovb %rax, data_sec_pos(%rdx)
	pop %r9
	pop %r8
	; increment
	inc %rdx
	inc %r10
	cmp %r10, %r9
	jl .L3
	xor %r10, %r10
	inc %rcx
	cmp %rcx, %r8
	jl .L3
; copy
	xor %rcx, %rcx
.L4:
	rrmov %rcx, %rdx
	add %rdx, %rbp
	mrmovb data_sec_pos(%rdx), %rax
	sub %rdx, %rbx
	rmmovb %rax, data_sec_pos(%rdx)
	inc %rcx
	cmp %rcx, %rbx
	jl .L4
	pop %r14
	pop %r13
	pop %r12
	pop %rbp
	pop %rbx
	ret
; end function next

; function paint(v) v:color
paint:
	push %rbx
	irmov $25000, %rbx
	irmov $0x000000ff, %r10
	rrmov %rdi, %r9
	rrmov %rbx, %rax	; address
	xor %rcx, %rcx		; pos = 0
.L1:
	mrmovb data_sec_pos(%rax), %r8
	rrmov %r9, %rsi
	test %r8, %r8
	cmove %r10, %rsi
	rrmov %rcx, %rdi
	call _draw
	inc %rcx				 ; pos++
	inc %rax				 ; address++
	cmp %rcx, %rbx
	jl .L1
	pop %rbx
	call repaint
	ret

; function color: a scheme of changing color
color:
	irmov $0xff000000, %r8
	irmov $0x00ff0000, %r9
	irmov $0x0000ff00, %r10
	rrmov %rdi, %rsi
	and %rsi, %r8
	cmp %rsi, %r8
	je .L21						; (255,x,x)
	rrmov %rdi, %rsi 
	and %rsi, %r9
	cmp %rsi, %r9
	je .L22						; (x,255,x)
	rrmov %rdi, %rsi
	and %rsi, %r10
	cmp %rsi, %r10
	je .L23						; (x,x,255)
.L21:
	rrmov %rdi, %rsi
	and %rsi, %r9
	cmp %rsi, %r9
	je .L32						; (255,255,0)
	rrmov %rdi, %rsi
	test %rsi, %r10  
	je .L24						; (255,x,0)
.L31:		; reduce blue
	irmov $0x00000500, %rsi
	sub %rdi, %rsi
	jmp .L27
.L22:
	rrmov %rdi, %rsi
	and %rsi, %r10
	cmp %rsi, %r10
	je .L33						; (0,255,255)
	rrmov %rdi, %rsi
	test %rsi, %r8
	je .L25						; (0,255,x)
.L32:		; reduce red
	irmov $0x05000000, %rsi
	sub %rdi, %rsi
	jmp .L27
.L23:
	rrmov %rdi, %rsi
	and %rsi, %r8
	cmp %rsi, %r8
	je .L31						; (255,0,255)
	rrmov %rdi, %rsi
	test %rsi, %r9
	je .L26						; (x,0,255)
.L33:		; reduce green
	irmov $0x00050000, %rsi
	sub %rdi, %rsi
	jmp .L27
.L24:		; add green
	irmov $0x00050000, %rsi
	add %rdi, %rsi
	jmp .L27
.L25:		; add blue
	irmov $0x00000500, %rsi
	add %rdi, %rsi
	jmp .L27
.L26:		; add red
	irmov $0x05000000, %rsi
	add %rdi, %rsi
.L27:
	rrmov %rdi, %rax
	ret

; function main
main:
	call init
	irmov $0x00ffffff, %rdi
	push %rdi
	call paint
.L0:
	call next
	pop %rdi
	call color
	push %rax
	rrmov %rax, %rdi
	call paint
	jmp .L0
	halt
```

​	测试结果：
![](F:\programming\workspace\DyVM\text\DyVM3.png)

![](F:\programming\workspace\DyVM\text\DyVM4.png)

![](F:\programming\workspace\DyVM\text\DyVM5.png)

![](F:\programming\workspace\DyVM\text\DyVM6.png)



## 八、问题与后续计划

### 1. 总结

​	本次实验中，我基本完成了自己预期的设计效果，完成了处理器的正常功能，虚拟存储系统的设计和实现。此外、完成了重要的文本输出和图形显示部分，尤其是图形显示部分，该部分的实现使得本机可以运行较为复杂的图形程序，产生更绚丽的显示效果。

###2. 当前问题

当前的设计中仍存在一些缺陷：

1. 当前的虚拟机未完成输入部件的制作；
2. 只支持64位整数操作，虽然提供了一些不同长度数据转换和传送的指令，仍然无法很好的适应32位或更低位程序的运行；
3. 缺乏浮点数操作指令，无法模拟实数运算；
4. 输入与输出缓冲区并不是真正意义上在内存中存在的缓冲区，而是相应设备中的存储区，不利于可能出现的复杂操作的实现；
5. 目前的设计中没有真实地模拟中断操作，在处理软中断时采用的策略是将其当作普通指令去运行，而没有设置中断标志；
6. 异常检测机制和应对措施不够健全。

###3. 后续计划

如果未来时间充裕，可能会有一下改进计划：

1. 完成输入部件的开发与测试；
2. 在内存中开辟真正的输入和输出缓冲区，并提供相应的库函数；
3. 真实模拟终端操作，在处理器中设置中断标志位；
4. 完善异常检测机制。



## 附件

### 文件结构(Intellij IDEA项目)

```
   DyVm
   |-- .idea			工程信息
   |-- asm				汇编代码
   |-- dyvm-v2			汇编程序
   |-- hex				汇编程序输出的目标代码
   |-- info				文本信息
   |-- out				编译输出
       |-- production
           |-- Main.class
           |-- ...
   |-- src				源代码
       |-- Main.java
       |-- Processor.java
       |-- AbstractFile.java
       |-- ReadableFile.java
       |-- WritableFile.java
       |-- IOBridge.java
       |-- Memory.java
       |-- Keyboard.java
       |-- TextOutput.java
       |-- Display.java
   |-- text				存储一些文本文件
   |-- assemble.bat   	调用汇编器的批处理程序
   |-- DyVm.iml
   |-- README.md
   |-- stylesheet.css 	虚拟机界面的样式表
```



### Main.java

```Java
import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.File;

public class Main extends Application {

  private final int DisplayWidth = 400;
  private final int DisplayHeight = 250;
  private final int Width = 800;
  private final int Height = 500;

  private Processor processor = new Processor();
  private IOBridge ioBridge = new IOBridge();
  private Memory memory = new Memory();
  private Keyboard keyboard = new Keyboard();
  private TextOutput textOutput = new TextOutput();
  private Display display = new Display(DisplayWidth, DisplayHeight);

  public Main() {
    processor.setIOBridge(ioBridge);
    memory.setIOBridge(ioBridge);
    keyboard.setIOBridge(ioBridge);
    textOutput.setIOBridge(ioBridge);
    display.setIOBridge(ioBridge);
  }

  @Override
  public void start(Stage primaryStage) {
    // initialize
    Group root = new Group();

    Processor.ProcessorPane processorPane = processor.getPane();
    Memory.MemoryPane memoryPane = memory.getPane();
    Keyboard.KeyboardPane keyboardPane = keyboard.getPane();
    TextOutput.TextOutputPane textOutputPane = textOutput.getPane();
    Display.DisplayCanvas displayCanvas = display.getCanvas();

    root.getChildren().addAll(
        processorPane,
        memoryPane,
        keyboardPane,
        textOutputPane,
        displayCanvas
    );

    displayCanvas.setWidth(DisplayWidth);
    displayCanvas.setHeight(DisplayHeight);
    displayCanvas.setLayoutX(0);
    displayCanvas.setLayoutY(0);

    int w = DisplayWidth / 2;
    keyboardPane.setPrefSize(w, Height - DisplayHeight);
    keyboardPane.setLayoutX(0);
    keyboardPane.setLayoutY(DisplayHeight);

    textOutputPane.setPrefSize(w, Height - DisplayHeight);
    textOutputPane.setLayoutX(w);
    textOutputPane.setLayoutY(DisplayHeight);

    processorPane.setPrefSize(Width - DisplayWidth, DisplayHeight);
    processorPane.setLayoutX(DisplayWidth);
    processorPane.setLayoutY(0);

    memoryPane.setPrefSize(Width - DisplayWidth, Height - DisplayHeight);
    memoryPane.setLayoutX(DisplayWidth);
    memoryPane.setLayoutY(DisplayHeight);

    processorPane.configureLoadButton(primaryStage);

    Scene scene = new Scene(root, Width, Height);
    // add css file
    File file = new File("stylesheet.css");
    scene.getStylesheets().add("file:///" + file.getAbsolutePath().replace('\\', '/'));

    primaryStage.setTitle("DyVM");
    primaryStage.setScene(scene);
    primaryStage.show();
  }

}
```



### Processor.java

```Java
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.util.Duration;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Processor {

  // normal speed
  private final static Duration duration1 = Duration.millis(1);
  // faster speed
  private final static Duration duration2 = Duration.millis(1);

  // running mode
  private int mode = 0;
  // 0: paused/halted/single-step running
  // 1: running at normal speed
  // 2: running at a faster speed

  /* virtual memory (abstract files) */
  private IOBridge ioBridge = null;

  private ProcessorPane pane = new ProcessorPane();

  // timeline for mode == 1
  private Timeline tlslow = new Timeline();
  // timeline for mode == 2
  private Timeline tlfast = new Timeline();
  // timeline for refreshing
  private Timeline tlref = new Timeline();

  public Processor() {
    // read instruction types
    Scanner in = null;
    try {
      in = new Scanner(new File("./info/ins_type.txt"));
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
    while (in.hasNext()) {
      int icode, type;
      icode = in.nextInt();
      type = in.nextInt();
      insTypes[icode] = type;
    }
    in.close();

    // init tlslow
    tlslow.setCycleCount(Timeline.INDEFINITE);
    tlslow.getKeyFrames().add(new KeyFrame(duration1,
        (e) -> {
          try {
            next();
          } catch (Exception e1) {
            handleException(e1);
          }
        })
    );
    // init tlfast
    tlfast.setCycleCount(Timeline.INDEFINITE);
    tlfast.getKeyFrames().add(new KeyFrame(duration2,
        (e) -> {
          try {
            for (int i = 0; i < 15000; i++) next();
          } catch (Exception e1) {
            handleException(e1);
          }
        })
    );
    // init tlref
    tlref.setCycleCount(Timeline.INDEFINITE);
    tlref.getKeyFrames().add(
        new KeyFrame(Duration.millis(50), e -> {
          try {
            refresh();
          } catch (Exception e1) {
            handleException(e1);
          }
        })
    );
    tlref.play();
  }

  private void handleException(Exception e) {
    if (mode == 1) tlslow.pause();
    else if (mode == 2) tlfast.pause();
    mode = 0;
    loaded = false;
    tlfast.stop();
    e.printStackTrace();
  }

  public void setIOBridge(IOBridge iobrg) {
    ioBridge = iobrg;
    ioBridge.setProcessor(this);
  }

  public ProcessorPane getPane() {
    return pane;
  }

  /* program counter */
  private int pc;

  /*
    conditional code
    cc[2]: ZF (zero)
    cc[1]: SF (signed)
    cc[0]: OF (overflow)
  */
  private byte cc;

  private boolean cond(int sel) {
    /* return the conditional state */
    boolean ret = true;
    boolean zf = false, sf = false, of = false;
    if ((cc & 4) > 0) zf = true;
    if ((cc & 2) > 0) sf = true;
    if ((cc & 1) > 0) of = true;
    switch (sel) {
      case 1: ret = zf; break; // e
      case 2: ret = !zf; break; // ne
      case 3: ret = (sf == of) && !zf; break; // g
      case 4: ret = (sf == of); break; // ge
      case 5: ret = sf ^ of; break; // l
      case 6: ret = (sf ^ of) || zf; break; // le
    }
    return ret;
  }

  /* state */
  private byte state;

  /* registers */
  private long[] regs = new long[15];
  final private int rsp = 4;

  /* instructions */
  private int[] insTypes = new int[15];

  private int insLen;
  private byte[] ir = new byte[10];

  /*
   * ******** DISPLAY ********************************
   */

  private void refresh() throws Exception {
    pane.refresh();
  }

  /*
   * ******** PROCESS ********************************
   */

  private boolean loaded = false;
  private int nextPC;

  private void fetch() throws Exception {
    /* fetch instruction */
    byte op = ioBridge.readb(pc + Memory.OBJECT_SECTION_POS);
    ir[0] = op;
    int type = insTypes[op >> 4 & 0xf];
    // 0: null
    // 1: r
    // 2: rr
    // 3: ri
    // 4: rri
    // 5: i

    switch (type) {
      case 0: insLen = 1; break;
      case 1: insLen = 2; break;
      case 2: insLen = 2; break;
      case 3: insLen = 10; break;
      case 4: insLen = 10; break;
      case 5: insLen = 9; break;
    }

    nextPC = pc + insLen;

    /* store it in instruction registers */
    for (int i = 1; i < insLen; i++) {
      ir[i] = ioBridge.readb(pc + i + Memory.OBJECT_SECTION_POS);
    }
  }

  private void exec() throws Exception {
    /* decode and exec */
    byte icode = (byte) (ir[0] >> 4 & 0xf);
    byte ifun = (byte) (ir[0] & 0xf);

    switch (icode) {
      case 0: runIns0(ifun); break;
      case 1: runIns1(ifun); break;
      case 2: runIns2(ifun); break;
      case 3: runIns3(ifun); break;
      case 4: runIns4(ifun); break;
      case 5: runIns5(ifun); break;
      case 6: runIns6(ifun); break;
      case 7: runIns7(ifun); break;
      case 8: runIns8(ifun); break;
      case 9: runIns9(ifun); break;
    }
    /* update pc */
    pc = nextPC;
  }

  private void init() throws Exception {
    /* initialize the processor for the newly loaded program */
    loaded = true;
    /* initialize program counter */
    pc = (int) ioBridge.readq(Memory.OBJECT_SECTION_POS);
    /* clear output buffer */
    ioBridge.setOutputBufferSize(0);
    /* clear the registers */
    for (int i = 0; i < 15; i++) {
      regs[i] = 0;
    }
    /* reset the stack register */
    regs[rsp] = Memory.STACK_SECTION_LIMIT;
    /* put a random seed in memory */
    ioBridge.setRandomSeed((int) System.currentTimeMillis() % 48271);
    ioBridge.clearDisplay();
    ioBridge.clearTextOutput();
  }

  private void next() throws Exception {
    /* run the next instruction cycle */
    if (loaded) {
      fetch();
      exec();
    }
  }

  private void runIns0(byte ifun) throws Exception {
    switch (ifun) {
      case 0:
        throw new Exception("HALT");
      case 1:
        break;
      case 2:
        nextPC = (int) ioBridge.readq((int) regs[rsp]);
        regs[rsp] += 8;
        break;
      case 3:
        // TODO
        break;
    }
  }

  private void runIns1(byte ifun) {
    if (ifun == 0) {
      byte rA = (byte) (ir[1] >> 4 & 0xf);
      long imme = 0;
      for (int i = 0; i < 8; i++) {
        imme += ((long)ir[i + 2] & 0xff) << (i << 3);
      }
      regs[rA] = imme;
    }
  }

  private void runIns2(byte ifun) throws Exception {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    byte rB = (byte) (ir[1] & 0xf);
    long imme = 0;
    for (int i = 0; i < 8; i++) {
      imme += ((long)ir[i + 2] & 0xff) << (i << 3);
    }
    int addr = (int) imme;
    if (rB != 0xf) addr += (int) regs[rB];
    switch (ifun) {
      case 0: ioBridge.writeq(addr, regs[rA]); break;
      case 1: ioBridge.writel(addr, (int) regs[rA]); break;
      case 2: ioBridge.writew(addr, (short) regs[rA]); break;
      case 3: ioBridge.writeb(addr, (byte) regs[rA]); break;
      case 4: regs[rA] = ioBridge.readq(addr); break;
      case 5: regs[rA] = 0xffffffffL & (long) ioBridge.readl(addr); break;
      case 6: regs[rA] = 0xffffL & (long) ioBridge.readw(addr); break;
      case 7: regs[rA] = 0xffL & (long) ioBridge.readb(addr); break;
    }
  }

  private void runIns3(byte ifun) {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    byte rB = (byte) (ir[1] & 0xf);
    boolean cnd = cond(ifun);
    if (cnd) regs[rB] = regs[rA];
  }

  private void runIns4(byte ifun) {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    byte rB = (byte) (ir[1] & 0xf);
    long vA = regs[rA];
    long vB = regs[rB];
    long vC = 0;

    boolean zf, sf, of = false;

    switch (ifun) {
      case 0: // add
        vC = vA + vB;
        of = (vA < 0 == vB < 0) && (vA < 0 != vC < 0);
        break;
      case 1: // sub
        vC = vA - vB;
        of = (vA < 0 != vB < 0) && (vA < 0 != vC < 0);
        break;
      case 2: // and
        vC = vA & vB; break;
      case 3: // or
        vC = vA | vB; break;
      case 4: // xor
        vC = vA ^ vB; break;
      case 5: // sal
        vC = vA << (vB & 0x3f); break;
      case 6: // sar
        vC = vA >> (vB & 0x3f); break;
      case 7: // shr
        vC = vA >>> (vB & 0x3f); break;
      case 8: // mul
        vC = vA * vB; break;
      case 9: // idiv
        vC = vA / vB;
        regs[0] = vA % vB;
        if (rA == 0) vC = regs[0];
        break;
    }

    zf = vC == 0;
    sf = vC < 0;
    regs[rA] = vC;

    cc = 0;
    if (zf) cc |= 4;
    if (sf) cc |= 2;
    if (of) cc |= 1;
  }

  private void runIns5(byte ifun) {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    long vA = regs[rA];
    long vC = 0;

    boolean zf, sf, of = false;
    switch (ifun) {
      case 0: vC = ~vA; break; // not
      case 1: vC = -vA; break; // neg
      case 2:
        vC = vA + 1;
        of = vC < 0 && vA > 0;
        break; // inc
      case 3:
        vC = vA - 1;
        of = vC > 0 && vA < 0;
        break; // dec
      case 4: vC = (long) (int) vA; break; // cltq
      case 5: vC = (long) (short) vA; break; // cwtq
      case 6: vC = (long) (byte) vA; break; // cbtq
      case 7: vC = vA & 0xffffffffL; break; // cqtl
      case 8: vC = vA & 0xffffL; break; // cqtw
      case 9: vC = vA & 0xffL; break; // cqtb
    }

    regs[rA] = vC;

    zf = (vC == 0);
    sf = (vC < 0);
    cc = 0;
    if (zf) cc |= 4;
    if (sf) cc |= 2;
    if (of) cc |= 1;
  }

  private void runIns6(byte ifun) {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    byte rB = (byte) (ir[1] & 0xf);
    long vA = regs[rA];
    long vB = regs[rB];
    long vC = 0;

    boolean sf, zf, of = false;

    switch (ifun) {
      case 0: // cmp
        vC = vA - vB;
        of = (vA < 0 != vB < 0) && (vA < 0 != vC < 0);
        break;
      case 1: // test
        vC = vA & vB;
        break;
    }

    zf = (vC == 0);
    sf = (vC < 0);
    cc = 0;
    if (zf) cc |= 4;
    if (sf) cc |= 2;
    if (of) cc |= 1;
  }

  private void runIns7(byte ifun) throws Exception {
    /* branch ins */
    int target = 0;
    for (int i = 0; i < 4; i++) {
      target += (((int)ir[i + 1] & 0xff) << (i << 3));
    }
    boolean cnd = cond(ifun);
    if (ifun == 7) {
      ioBridge.writeq((int) (regs[rsp] - 8), nextPC);
      regs[rsp] -= 8;
    }
    if (cnd) nextPC = target;
  }

  private void runIns8(byte ifun) throws Exception {
    byte rA = (byte) (ir[1] >> 4 & 0xf);
    if (ifun == 0) {    // push
      ioBridge.writeq((int) (regs[rsp] - 8), regs[rA]);
      regs[rsp] -= 8;
    } else if (ifun == 1) {  // pop
      long vA = ioBridge.readq((int) regs[rsp]);
      regs[rsp] += 8;
      regs[rA] = vA;
    }
  }

  private void runIns9(byte ifun) throws Exception {
    /* interrupt */
    long imme = 0;
    for (int i = 0; i < 8; i++) {
      imme += ((long)ir[1 + i] & 0xff) << (i << 3);
    }
    ioBridge.interupt((int) imme);
  }

  /*
   * *********** END PROCESS ***********************
   */


  public class ProcessorPane extends BorderPane {
    /* ControlPane of the Processor */

    private Button btLoad = new Button("Load");
    private Button btRun = new Button("Run");
    private Button btFast = new Button("Fast"); // execute at a faster speed
    private Button btPause = new Button("Pause");
    private Button btStep = new Button("Step"); // single step execution
    private Button btHalt = new Button("Halt");

    private Label[] registers = new Label[15];
    private Label PCLabel;

    private GridPane centerPane = new GridPane();
    private HBox bottomPane = new HBox();

    public ProcessorPane() {
      configureBottomPane();
      bottomPane.getChildren().addAll(btLoad, btRun, btFast, btPause, btStep, btHalt);
      bottomPane.setId("bottom-pane");
      setBottom(bottomPane);

      configureCenterPane();
      centerPane.setId("center-pane");
      setCenter(centerPane);
    }

    private void configureCenterPane() {
      /* show registers */
      String[] regNames = {
          "%rax", "%rcx", "%rdx", "%rbx", "%rsp", "%rbp", "%rsi", "%rdi",
          "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14",
      };
      final int nameWidth = 50;
      for (int i = 0; i < 15; i++) {
        /* show register name */
        Label name = new Label(regNames[i]);
        name.setId("register-name");
        /* show register value */
        Label label = new Label();
        label.setId("register-value");
        centerPane.widthProperty().addListener(ov -> {
          name.setPrefWidth(nameWidth);
          label.setPrefWidth(centerPane.getWidth() / 2 - nameWidth);
        });
        centerPane.heightProperty().addListener(ov -> {
          name.setPrefHeight(centerPane.getHeight() / 8);
          label.setPrefHeight(centerPane.getHeight() / 8);
        });
        registers[i] = label;
        centerPane.add(name, i / 8 * 2, i % 8);
        centerPane.add(label, i / 8 * 2 + 1, i % 8);
      }
      /* show pc */
      Label PCName = new Label("PC");
      PCName.setId("pc-name");
      PCLabel = new Label();
      PCLabel.setId("pc-value");
      centerPane.widthProperty().addListener(ov -> {
        PCName.setPrefWidth(nameWidth);
        PCLabel.setPrefWidth(centerPane.getWidth() / 2 - nameWidth);
      });
      centerPane.heightProperty().addListener(ov -> {
        PCName.setPrefHeight(centerPane.getHeight() / 8);
        PCLabel.setPrefHeight(centerPane.getHeight() / 8);
      });

      centerPane.add(PCName, 2, 7);
      centerPane.add(PCLabel, 3, 7);
    }

    private void configureBottomPane() {
      bottomPane.widthProperty().addListener(ov -> {
        btLoad.setPrefWidth(getWidth() / 6);
        btRun.setPrefWidth(getWidth() / 6);
        btFast.setPrefWidth(getWidth() / 6);
        btPause.setPrefWidth(getWidth() / 6);
        btStep.setPrefWidth(getWidth() / 6);
        btHalt.setPrefWidth(getWidth() / 6);
      });

      btRun.setOnAction(e -> {
        if (mode == 2) tlfast.pause();
        mode = 1;
        tlslow.play();
      });
      btFast.setOnAction(e -> {
        if (mode == 1) tlslow.pause();
        mode = 2;
        tlfast.play();
      });

      btPause.setOnAction(e -> {
        if (mode == 1) {
          tlslow.pause();
        } else if (mode == 2) {
          tlfast.pause();
        }
        mode = 0;
      });

      btHalt.setOnAction(e -> {
        if (mode == 1) {
          tlslow.stop();
        } else if (mode == 2) {
          tlfast.stop();
        }
        mode = 0;
        try {
          if (loaded) init();
        } catch (Exception e1) {
          e1.printStackTrace();
        }
      });

      btStep.setOnAction(e -> {
        if (mode == 1) tlslow.pause();
        else if (mode == 2) tlfast.pause();
        mode = 0;
        try {
          next();
        } catch (Exception e1) {
          handleException(e1);
        }
      });
    }

    public void configureLoadButton(Stage stage) {
      FileChooser fileChooser = new FileChooser();
      fileChooser.setTitle("Choose object file");
      fileChooser.setInitialDirectory(new File("./hex/"));
      fileChooser.getExtensionFilters().add(
          new FileChooser.ExtensionFilter("HEX", "*.hex")
      );
      /* load object file */
      btLoad.setOnAction((e) -> {
        if (mode == 1) tlslow.stop();
        else if (mode == 2) tlfast.stop();
        mode = 0;
        File file = fileChooser.showOpenDialog(stage);
        if (file != null) {
          try {
            ioBridge.loadObject(file);
            init();
          } catch (Exception e1) {
            e1.printStackTrace();
          }
        }
      });
    }

    public void refresh() throws Exception {
      /* update the values of registers and memory units */
      for (int i = 0; i < 15; i++) {
        registers[i].setText(Long.toString(regs[i]));
      }
      PCLabel.setText(Integer.toHexString(pc));
      ioBridge.refresh();
    }
  }
}
```



### AbstractFile.java

```java
public interface AbstractFile {
  int getMaxSize();
  boolean isReadable();
  boolean isWritable();
}
```



### ReadableFile.java

```java
public interface ReadableFile extends AbstractFile {
  byte readb(int index) throws Exception;
  short readw(int index) throws Exception;
  int readl(int index) throws Exception;
  long readq(int index) throws Exception;
}
```



###WritableFile.java

```java
public interface WritableFile extends AbstractFile {
  void writeb(int index, byte val) throws Exception;
  void writew(int index, short val) throws Exception;
  void writel(int index, int val) throws Exception;
  void writeq(int index, long val) throws Exception;
}
```



### IOBridge.java

```java
import java.io.*;

public class IOBridge {

  private AbstractFile[] files = new AbstractFile[4];

  private Processor processor = null;

  private Memory memory;
  private Keyboard keyboard;
  private TextOutput textOutput;
  private Display display;

  public void setMemory(Memory memory) {
    this.memory = memory;
    files[0] = memory;
  }

  public void setKeyboard(Keyboard keyboard) {
    this.keyboard = keyboard;
    files[1] = keyboard;
  }

  public void setTextOutput(TextOutput textOutput) {
    this.textOutput = textOutput;
    files[2] = textOutput;
  }

  public void setDisplay(Display display) {
    this.display = display;
    files[3] = display;
  }

  public void setProcessor(Processor pro) {
    processor = pro;
  }

  public synchronized void setKeyboardInterrupt() {
    // TODO
  }

  public void loadObject(File file) throws IOException {
    memory.load(file);
  }

  public void clearTextOutput() {
    textOutput.clear();
  }

  public void clearDisplay() {
    display.clear();
  }

  public void refresh() throws Exception {
    memory.refresh();
  }

  public synchronized void setInputBufferSize() throws Exception {
    // TODO
  }

  public synchronized void setOutputBufferSize(long value) throws Exception {
    memory.writeq(8, value);
  }

  public long getOutputBufferSize() throws Exception {
    return memory.readq(8);
  }

  public synchronized void setRandomSeed(int value) throws Exception {
    memory.writel(16, value);
  }

  public void interupt(int value) throws Exception {
    switch (value) {
      case 1: /* TODO */ break;
      case 2: textOutput.print(); break;
      case 3: display.paint(); break;
    }
  }

  private int absoluteIndex;

  private AbstractFile getAbstractFile(int index) throws Exception {
    absoluteIndex = index;
    if (absoluteIndex < 0) throw new Exception("^V^V^V^V^V^V^");
    for (AbstractFile file : files) {
      if (absoluteIndex < file.getMaxSize()) return file;
      absoluteIndex -= file.getMaxSize();
    }
    throw new Exception("Illegal Memory Address !");
  }

  private ReadableFile getReadableFile(int index) throws Exception {
    AbstractFile file = getAbstractFile(index);
    if (!file.isReadable()) throw new Exception("NotAReadableFile");
    return (ReadableFile)file;
  }

  private WritableFile getWritableFile(int index) throws Exception {
    AbstractFile file = getAbstractFile(index);
    if (!file.isWritable()) throw new Exception("NotAWritableFile");
    return (WritableFile)file;
  }

  public byte readb(int index) throws Exception {
    ReadableFile file = getReadableFile(index);
    return file.readb(absoluteIndex);
  }

  public short readw(int index) throws Exception {
    ReadableFile file = getReadableFile(index);
    return file.readw(absoluteIndex);
  }

  public int readl(int index) throws Exception {
    ReadableFile file = getReadableFile(index);
    return file.readl(absoluteIndex);
  }

  public long readq(int index) throws Exception {
    ReadableFile file = getReadableFile(index);
    return file.readq(absoluteIndex);
  }

  public void writeb(int index, byte val) throws Exception {
    WritableFile file = getWritableFile(index);
    file.writeb(absoluteIndex, val);
  }

  public void writew(int index, short val) throws Exception {
    WritableFile file = getWritableFile(index);
    file.writew(absoluteIndex, val);
  }

  public void writel(int index, int val) throws Exception {
    WritableFile file = getWritableFile(index);
    file.writel(absoluteIndex, val);
  }

  public void writeq(int index, long val) throws Exception {
    WritableFile file = getWritableFile(index);
    file.writeq(absoluteIndex, val);
  }

}
```



### Memory.java

```java
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;

import java.io.*;

public class Memory implements ReadableFile, WritableFile {

  private final int MAX_SIZE;
  private byte[] ram;

  private IOBridge ioBridge = null;

  private MemoryPane pane = new MemoryPane();

  public MemoryPane getPane() {
    return pane;
  }

  final public static int RESERVE_SECTION_POS = 0x0000000;
  final public static int OBJECT_SECTION_POS = 0x1000000;
  final public static int STACK_SECTION_POS = 0x2000000;
  final public static int STACK_SECTION_LIMIT = 0x3000000;
  final public static int DATA_SECTION_POS = 0x3000000;

  public Memory() {
    this(0x10000000);
  }

  public Memory(int maxSize) {
    ram = new byte[maxSize];
    MAX_SIZE = maxSize;
  }

  public void setIOBridge(IOBridge iob) {
    ioBridge = iob;
    ioBridge.setMemory(this);
  }

  @Override
  public int getMaxSize() {
    return MAX_SIZE;
  }

  @Override
  public boolean isReadable() {
    return true;
  }

  @Override
  public boolean isWritable() {
    return true;
  }

  public void load(File file) throws IOException {
    RandomAccessFile raf = new RandomAccessFile(file, "r");
    raf.read(ram, OBJECT_SECTION_POS, MAX_SIZE - OBJECT_SECTION_POS);
  }

  @Override
  public byte readb(int index) throws Exception {
    if (index < 0 || index >= MAX_SIZE) {
      throw new Exception();
    }
    return ram[index];
  }

  @Override
  public short readw(int index) throws Exception {
    if (index < 0 || index + 2 > MAX_SIZE) {
      throw new Exception();
    }
    short val = (short) (((short)ram[index] << 8) +
        ((short) ram[index + 1] & 0xff));
    return val;
  }

  @Override
  public int readl(int index) throws Exception {
    if (index < 0 || index + 4 > MAX_SIZE) {
      throw new Exception();
    }
    int val = 0;
    for (int i = 3; i >= 0; i--) {
      val <<= 8;
      val += ((int) ram[index + i] & 0xff);
    }
    return val;
  }

  @Override
  public long readq(int index) throws Exception {
    if (index < 0 || index + 8 > MAX_SIZE) {
      throw new Exception();
    }
    long val = 0;
    for (int i = 7; i >= 0; i--) {
      val <<= 8;
      val += ((long) ram[index + i] & 0xff);
    }
    return val;
  }

  @Override
  public void writeb(int index, byte val) throws Exception {
    if (index < 0 || index >= MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = val;
  }

  @Override
  public void writew(int index, short val) throws Exception {
    if (index < 0 || index + 2 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
  }

  @Override
  public void writel(int index, int val) throws Exception {
    if (index < 0 || index + 4 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
    ram[index + 2] = (byte) (val >> 16 & 0xff);
    ram[index + 3] = (byte) (val >> 24 & 0xff);
  }

  @Override
  public void writeq(int index, long val) throws Exception {
    if (index < 0 || index + 8 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
    ram[index + 2] = (byte) (val >> 16 & 0xff);
    ram[index + 3] = (byte) (val >> 24 & 0xff);
    ram[index + 4] = (byte) (val >> 32 & 0xff);
    ram[index + 5] = (byte) (val >> 40 & 0xff);
    ram[index + 6] = (byte) (val >> 48 & 0xff);
    ram[index + 7] = (byte) (val >> 56 & 0xff);
  }

  public void refresh() throws Exception {
    pane.refresh();
  }

  public class MemoryPane extends GridPane {
    private TextField[] address = new TextField[10];
    private Label[] value = new Label[10];

    public MemoryPane() {
      this.setId("memory-pane");
      // add components
      for (int i = 0; i < 10; i++) {
        TextField tf = new TextField();
        Label lb = new Label();
        this.widthProperty().addListener(ov -> {
          tf.setPrefWidth(getWidth() / 2);
          lb.setPrefWidth(getWidth() - tf.getWidth());
        });
        this.heightProperty().addListener(ov -> {
          tf.setPrefHeight(getHeight() / 10);
          lb.setPrefHeight(getHeight() / 10);
        });
        tf.setId("memory-text-field");
        lb.setId("memory-label");
        address[i] = tf;
        value[i] = lb;
        this.add(tf, 0, i);
        this.add(lb, 1, i);
      }
    }

    private int parseInt(String str) {
      if (str.isEmpty()) return -1;

      StringBuilder builder = new StringBuilder(str);
      boolean hex = false;
      if (builder.length() > 2 && builder.substring(0, 2).equals("0x")) {
        hex = true;
        builder.delete(0, 2);
      }
      int val = 0;
      if (hex) {
        int len = builder.length();
        for (int i = 0; i < len; i++) {
          char c = builder.charAt(i);
          if (Character.isDigit(c) || Character.isAlphabetic(c)) {
            c = Character.toLowerCase(c);
            if (c > 'f') return -1;
            if (Character.isDigit(c)) val = (val << 4) + c - '0';
            else val = (val << 4) + c - 'a' + 10;
          } else return -1;
        }
      } else {
        int len = builder.length();
        for (int i = 0; i < len; i++) {
          char c = builder.charAt(i);
          if (Character.isDigit(c)) {
            val = val * 10 + c - '0';
          } else return -1;
        }
      }
      if (val + 16 > MAX_SIZE || val < 0) return -1;
      return val;
    }

    private void refresh() throws Exception {
      for (int i = 0; i < 10; i++) {
        int addr = parseInt(address[i].getText());
        if (addr == -1) {
          value[i].setText("");
        } else {
          StringBuffer strVal = new StringBuffer();
          for (int j = 0; j < 16; j++) {
            if (j > 0) strVal.append(' ');
            if (j == 8) strVal.append(' ');
            int val = 0xff & (int) readb(addr + j);
            StringBuffer byteVal = new StringBuffer(Integer.toHexString(val));
            if (byteVal.length() < 2) byteVal.insert(0, '0');
            strVal.append(byteVal);
          }
          value[i].setText(strVal.toString());
        }
      }
    }
  }

}
```



### Keyboard.java

```java
import javafx.scene.layout.Pane;

public class Keyboard implements ReadableFile {

  /*
   * TODO
   */

  public final int MAX_SIZE;
  private byte[] buffer;

  private IOBridge ioBridge = null;

  private KeyboardPane pane = new KeyboardPane();

  public Keyboard() {
    this(0x80000);
  }

  public Keyboard(int maxSize) {
    buffer = new byte[maxSize];
    MAX_SIZE = maxSize;
  }

  public void setIOBridge(IOBridge iob) {
    ioBridge = iob;
    ioBridge.setKeyboard(this);
  }

  public KeyboardPane getPane() {
    return pane;
  }

  @Override
  public int getMaxSize() {
    return MAX_SIZE;
  }

  @Override
  public boolean isReadable() {
    return true;
  }

  @Override
  public boolean isWritable() {
    return false;
  }

  @Override
  public byte readb(int index) throws Exception {
    if (index < 0 || index >= MAX_SIZE) {
      throw new Exception();
    }
    return buffer[index];
  }

  @Override
  public short readw(int index) throws Exception {
    if (index < 0 || index + 2 > MAX_SIZE) {
      throw new Exception();
    }
    short val = buffer[index + 1];
    val <<= 8;
    val += ((short) buffer[index] & 0xff);
    return val;
  }

  @Override
  public int readl(int index) throws Exception {
    if (index < 0 || index + 4 > MAX_SIZE) {
      throw new Exception();
    }
    int val = 0;
    for (int i = 3; i >= 0; i--) {
      val <<= 8;
      val += ((int) buffer[index + i] & 0xff);
    }
    return val;
  }

  @Override
  public long readq(int index) throws Exception {
    if (index < 0 || index + 8 > MAX_SIZE) {
      throw new Exception();
    }
    long val = 0;
    for (int i = 7; i >= 0; i--) {
      val <<= 8;
      val += ((long) buffer[index + i] & 0xff);
    }
    return val;
  }

  public class KeyboardPane extends Pane {
    public KeyboardPane() {
      this.setId("keyboard-pane");
    }
  }
}
```



### TextOutput.java

```java
import javafx.scene.control.TextArea;
import javafx.scene.layout.Pane;

public class TextOutput implements WritableFile {

  final private int MAX_SIZE = 0x80000;

  private byte[] ram = new byte[MAX_SIZE];

  private IOBridge ioBridge = null;

  private TextOutputPane pane = new TextOutputPane();

  public void setIOBridge(IOBridge iob) {
    ioBridge = iob;
    ioBridge.setTextOutput(this);
  }

  public TextOutputPane getPane() {
    return pane;
  }

  @Override
  public int getMaxSize() {
    return MAX_SIZE;
  }

  @Override
  public boolean isReadable() {
    return false;
  }

  @Override
  public boolean isWritable() {
    return true;
  }

  @Override
  public void writeb(int index, byte val) throws Exception {
    if (index < 0 || index >= MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = val;
  }

  @Override
  public void writew(int index, short val) throws Exception {
    if (index < 0 || index + 2 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
  }

  @Override
  public void writel(int index, int val) throws Exception {
    if (index < 0 || index + 4 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
    ram[index + 2] = (byte) (val >> 16 & 0xff);
    ram[index + 3] = (byte) (val >> 24 & 0xff);
  }

  @Override
  public void writeq(int index, long val) throws Exception {
    if (index < 0 || index + 8 > MAX_SIZE) {
      throw new Exception();
    }
    ram[index] = (byte) (val & 0xff);
    ram[index + 1] = (byte) (val >> 8 & 0xff);
    ram[index + 2] = (byte) (val >> 16 & 0xff);
    ram[index + 3] = (byte) (val >> 24 & 0xff);
    ram[index + 4] = (byte) (val >> 32 & 0xff);
    ram[index + 5] = (byte) (val >> 40 & 0xff);
    ram[index + 6] = (byte) (val >> 48 & 0xff);
    ram[index + 7] = (byte) (val >> 56 & 0xff);
  }

  public void clear() {
    /* clear the buffer and the output pane */
    pane.clear();
  }

  public synchronized void print() throws Exception {
    /* move the content from the buffer to the output pane
     * then clear the buffer */
    pane.print();
  }

  public class TextOutputPane extends Pane {
    private TextArea textArea = new TextArea();
    private String textStr = "";

    public TextOutputPane() {
      textArea.setText(textStr);
      this.widthProperty().addListener(ov ->
          textArea.setPrefWidth(this.getWidth()));
      this.heightProperty().addListener(ov ->
          textArea.setPrefHeight(this.getHeight()));
      textArea.setEditable(false);
      textArea.setId("text-output-text-area");
      this.setId("text-output-pane");
      this.getChildren().add(textArea);
    }

    public void clear() {
      textStr = "";
      textArea.setText(textStr);
    }

    public synchronized void print() throws Exception {
      long size = ioBridge.getOutputBufferSize();
      StringBuilder str = new StringBuilder();
      for (int i = 0; i < MAX_SIZE && i < size; i++) {
        str.append((char) ram[i]);
      }

      textStr += str;
      textArea.setText(textStr);
      textArea.setScrollTop(Double.MAX_VALUE);
      ioBridge.setOutputBufferSize(0);
    }
  }

}
```



### Display.java

```java
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;

public class Display implements WritableFile {

  final private int MAX_SIZE = 0x100000;
  final private int W;  // display's width
  final private int H;  // display's height
  final private int MAX_POS;

  private int[] ram = new int [MAX_SIZE];  // display's memory

  private IOBridge ioBridge = null;

  private DisplayCanvas canvas;

  public Display(int w, int h) {
    W = w / 2; H = h / 2;
    MAX_POS = W * H;
    if (MAX_POS > MAX_SIZE) {
      System.exit(0);
    }

    canvas = new DisplayCanvas();
    /* clear the memory */
    for (int i = 0; i < MAX_SIZE; i++) ram[i] = 0;
  }

  public void setIOBridge(IOBridge iob) {
    ioBridge = iob;
    ioBridge.setDisplay(this);
  }

  public DisplayCanvas getCanvas() {
    return canvas;
  }

  @Override
  public int getMaxSize() {
    return MAX_SIZE;
  }

  @Override
  public boolean isReadable() {
    return false;
  }

  @Override
  public boolean isWritable() {
    return true;
  }

  @Override
  public void writeb(int index, byte val) throws Exception {
    throw new Exception("Data size banned !");
  }

  @Override
  public void writew(int index, short val) throws Exception {
    throw new Exception("Data size banned !");
  }

  @Override
  public synchronized void writel(int index, int val) throws Exception {
    if (index > MAX_SIZE) {
      throw new Exception("Invalid index !");
    }
    if ((index & 3) > 0) {
      throw new Exception("Data aligning is required !");
    }
    index >>= 2;
    ram[index] = val;
  }

  @Override
  public void writeq(int index, long val) throws Exception {
    throw new Exception("Data size banned !");
  }

  public void clear() {
    /* clear the display */
    for (int i = 0; i < MAX_POS; i++) {
      ram[i] = 0;
    }
    canvas.paint();
  }

  public synchronized void paint() {
    /* paint current frame and clear the memory */
    canvas.paint();
    for (int i = 0; i < MAX_POS; i++) {
      ram[i] = 0;
    }
  }

  public class DisplayCanvas extends Canvas {

    private GraphicsContext gc;

    public DisplayCanvas() {
      super(W * 2, H * 2);
      gc = this.getGraphicsContext2D();
      paint();
    }

    public void paint() {
      /* draw pixels to the display */
      gc.setFill(Color.BLACK);
      gc.fillRect(0, 0, this.getWidth(), this.getHeight());

      int pos = 0;
      for (int x = 0; x < W; x++) {
        for (int y = 0; y < H; y++, pos++) {
          int value = ram[pos];
          int red = (value >> 24) & 0xff;
          int green = (value >> 16) & 0xff;
          int blue = (value >> 8) & 0xff;
          int alpha = value & 0xff;
          double r = red / 255.0;
          double g = green / 255.0;
          double b = blue / 255.0;
          double a = alpha / 255.0;
          gc.setFill(Color.color(r, g, b, a));
          gc.fillRect(x << 1, y << 1, 2, 2);
        }
      }
    }

  }

}
```

